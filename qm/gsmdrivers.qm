<?xml version="1.0" encoding="UTF-8"?>
<model version="2.3.2">
 <documentation>Simple model template for QP/C</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="MyEvt" superclass="qpc::QEvt">
   <attribute name="attr1" type="" visibility="0x00" properties="0x00"/>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="SerialDrv" superclass="qpc::QActive">
   <documentation>Just the serialport, it's a bit of a domain on it's own, thus separate AO</documentation>
   <attribute name="listen_timeout" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <attribute name="txbufferptr" type="void" visibility="0x00" properties="0x00"/>
   <statechart>
    <initial target="../1">
     <action>/* subscribe to the turn_on and turn_off signals */</action>
     <initial_glyph conn="4,2,5,0,8,3">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="off">
     <entry>/* disable serial peripheral to conserve power */</entry>
     <tran trig="TURN_ON" target="../../2">
      <tran_glyph conn="22,9,1,3,11,1,2">
       <action box="0,-2,9,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="4,5,18,12">
      <entry box="1,2,13,8"/>
     </state_glyph>
    </state>
    <state name="on">
     <entry>/* Enable serial peripheral, keep module serialport enabled via DTR, setup RING signal as wakeup source from STOP */</entry>
     <exit>/* put module to sleep via DTR, remove RING signal as wakeup source from STOP */</exit>
     <initial target="../5">
      <action>/* subscribe to the signals used */</action>
      <initial_glyph conn="46,13,4,0,3">
       <action box="2,0,6,2"/>
      </initial_glyph>
     </initial>
     <tran trig="TURN_OFF" target="../../1">
      <tran_glyph conn="35,15,3,1,-11,-1,-2">
       <action box="-10,-2,10,3"/>
      </tran_glyph>
     </tran>
     <state name="idle">
      <entry>/* arm sleep timer, check for txbuffer if so, signal TX_BUFFER_RDY (or just transition, I'm having trouble drawing this condition) */</entry>
      <exit>/* disarm sleep timer */</exit>
      <tran trig="RING" target="../../3">
       <action>/* we suppose the module wakes it's serialport in this case automagically */</action>
       <tran_glyph conn="71,33,2,0,6">
        <action box="-6,1,6,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TX_BUFFER_RDY" target="../../8">
       <action>/* set me-&gt;txbufferptr to the requires buffer */</action>
       <tran_glyph conn="67,31,3,0,-18,15">
        <action box="-17,2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="ENTER_RAW_MODE" target="../../4">
       <tran_glyph conn="91,24,1,1,18,47,-29">
        <action box="2,-2,16,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TIMEOUT" target="../../6">
       <tran_glyph conn="70,22,0,2,-5">
        <action box="0,-2,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="67,22,24,11">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="Listening">
      <documentation>/* TODO: how the poll for the serialport, I guess incoming data would have to be modelled as signals too */</documentation>
      <entry>/* arm the listen timer */</entry>
      <exit>/* disarm the timer */</exit>
      <tran trig="TIMEOUT" target="../../2">
       <action>/* Signal the caller about error somehow */</action>
       <tran_glyph conn="92,47,1,1,4,-17,-5">
        <action box="4,-2,9,2"/>
       </tran_glyph>
      </tran>
      <tran trig="MESSAGE_RECEIVED" target="../../2">
       <action>/* signal the message contents at least to the module state machine */</action>
       <tran_glyph conn="87,39,0,2,-6">
        <action box="-8,-3,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DATA_RECEIVED">
       <action>/* parse the data, signal MESSAGE_RECEIVED if we have a full line of data */</action>
       <tran_glyph conn="66,49,3,-1,10">
        <action box="0,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="66,39,26,16">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="raw_mode">
      <documentation>raw mode for sms/ip/whatnot, normal message parsing is disabled</documentation>
      <tran trig="EXIT_RAW_MODE" target="../../2">
       <tran_glyph conn="80,75,1,1,27,-47,-16">
        <action box="0,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="41,66,39,14"/>
     </state>
     <state name="initializing">
      <entry>/* Initialize the serialport and module sleep modes,signal INIT_DONE when ready */</entry>
      <tran trig="SERIAL_INIT_DONE" target="../../2">
       <tran_glyph conn="55,20,1,3,10,9,2">
        <action box="0,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="38,16,17,8">
       <entry box="1,2,15,3"/>
      </state_glyph>
     </state>
     <state name="sleeping">
      <entry>/* sleep the module via DTR */</entry>
      <exit>/* wake the module via DTR */</exit>
      <tran trig="TX_BUFFER_RDY" target="../../7">
       <action>/* set me-&gt;txbufferptr to the requires buffer */</action>
       <tran_glyph conn="80,14,1,3,9">
        <action box="-3,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="65,10,15,7">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="module_wakeup">
      <entry>/* arm timer for the required wakeup time */</entry>
      <exit>/* disarm the wakeup timer */</exit>
      <tran trig="TIMEOUT" target="../../2">
       <tran_glyph conn="91,17,2,0,3,-6,2">
        <action box="0,0,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="89,10,17,7">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="trasmitting">
      <entry>/* arm the tx_timeout timer, transmit the buffer, signal buffer_done when ready */</entry>
      <exit>/* disarm tx_timeout, clear me-&gt;txbufferptr */</exit>
      <tran trig="TX_BUFFER_DONE" target="../../3">
       <tran_glyph conn="53,50,1,3,11,2,2">
        <action box="-2,-2,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TIMEOUT" target="../../2">
       <action>/* signal TX failure */</action>
       <tran_glyph conn="45,53,2,1,9,59,-36,-13">
        <action box="1,1,10,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="37,46,16,7">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="35,6,80,77">
      <entry box="1,2,7,2"/>
      <exit box="1,4,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="116,108"/>
   </statechart>
  </class>
  <class name="GSMDrv" superclass="qpc::QActive">
   <documentation>The main module driver HSM
</documentation>
   <attribute name="smsstructptr" type="void" visibility="0x00" properties="0x00">
    <documentation>pointer to buffer for sms struct (which defines the sender/recipient number and a pointer to a char buffer containing the message)</documentation>
   </attribute>
   <statechart>
    <initial target="../1">
     <initial_glyph conn="4,2,5,0,6,3">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="cut_off">
     <documentation>The FET is off, the module has no vbat</documentation>
     <entry>/* do nothing, the power domain might be requested by another thread */</entry>
     <tran trig="power_on" target="../../2/3">
      <tran_glyph conn="17,5,0,0,-3,35,7">
       <action box="0,-3,8,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="4,5,15,8">
      <entry box="1,2,5,2"/>
     </state_glyph>
    </state>
    <state name="vbat_connected">
     <entry>/* request FET power domain */</entry>
     <exit>/* release FET power domain */</exit>
     <initial target="../2">
      <initial_glyph conn="30,9,4,0,3">
       <action box="0,-2,6,2"/>
      </initial_glyph>
     </initial>
     <tran trig="cut_off" target="../../1">
      <tran_glyph conn="22,17,3,2,-12,-4">
       <action box="-10,-2,6,2"/>
      </tran_glyph>
     </tran>
     <state name="off">
      <documentation>powered off via the &quot;power button&quot; on the SIMCOM module</documentation>
      <entry>/* do nothing, the power button is handled by the on-state entry/exit */</entry>
      <tran trig="power_on" target="../../3">
       <tran_glyph conn="25,19,2,3,6,9">
        <action box="-1,6,8,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="24,12,9,7">
       <entry box="1,2,5,2"/>
      </state_glyph>
     </state>
     <state name="on">
      <documentation>Module is powered on via the &quot;power button&quot;</documentation>
      <entry>/* poweron the module via the power-button sequence, signal the serialport driver to start */</entry>
      <exit>/* poweroff the module via the power-button sequence, signal the serialport driver to stop */</exit>
      <initial target="../2">
       <initial_glyph conn="38,17,5,3,6">
        <action box="0,-2,6,2"/>
       </initial_glyph>
      </initial>
      <tran trig="power_off" target="../../2">
       <tran_glyph conn="34,23,3,2,-7,-4">
        <action box="-7,-2,6,2"/>
       </tran_glyph>
      </tran>
      <state name="wait_for_serial_init">
       <tran trig="SERIAL_INIT_DONE" target="../../3">
        <tran_glyph conn="69,16,1,0,2,5">
         <action box="0,-2,15,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="44,13,25,6"/>
      </state>
      <state name="cfun_0">
       <documentation>minimal functionality mode</documentation>
       <entry>/* send AT+CFUN=0,0 */</entry>
       <tran trig="GPIO_CMD">
        <action>/* ask the serial driver about the GPIO status */</action>
        <tran_glyph conn="37,28,3,-1,5">
         <action box="0,-2,10,2"/>
        </tran_glyph>
       </tran>
       <tran trig="BAT_READ">
        <action>/* ask the serial driver about the battery status */</action>
        <tran_glyph conn="37,32,3,-1,5">
         <action box="0,-2,8,2"/>
        </tran_glyph>
       </tran>
       <tran trig="GSM_ONLINE" target="../3">
        <tran_glyph conn="37,36,3,3,11">
         <action box="0,-2,11,2"/>
        </tran_glyph>
       </tran>
       <state name="cfun_1">
        <documentation>The full-functionality mode</documentation>
        <entry>/* send AT+CFUN=1,0 */</entry>
        <initial target="../2">
         <initial_glyph conn="62,30,4,0,2">
          <action box="0,-2,6,2"/>
         </initial_glyph>
        </initial>
        <tran trig="AT_CMD">
         <action>/* ask the serial driver for status of given AT command the does not require network yet */</action>
         <tran_glyph conn="142,39,1,-1,-13">
          <action box="-10,0,9,2"/>
         </tran_glyph>
        </tran>
        <state name="check_sim">
         <entry>/* check sim state, emit correct signal/trigger */</entry>
         <tran trig="NO_SIM" target="../../..">
          <action>/* if we have no SIM there is no point for cfun1, drop to cfun0 */</action>
          <tran_glyph conn="50,38,3,0,7,-17">
           <action box="0,-2,6,2"/>
          </tran_glyph>
         </tran>
         <tran trig="PIN_REQ" target="../../3">
          <tran_glyph conn="50,40,3,3,30">
           <action box="0,-2,6,2"/>
          </tran_glyph>
         </tran>
         <tran trig="PIN_OK" target="../../4">
          <tran_glyph conn="54,43,2,0,3">
           <action box="0,-2,6,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="50,32,21,11">
          <entry box="1,2,5,2"/>
         </state_glyph>
        </state>
        <state name="pin_required">
         <entry>/* check if we have PIN configured, of se send it and emit PIN_SENT, otherwise emit NO_PIN */</entry>
         <tran trig="PIN_SENT" target="../../2">
          <tran_glyph conn="80,37,3,1,-7,-1,-2">
           <action box="-8,-4,8,2"/>
          </tran_glyph>
         </tran>
         <tran trig="NO_PIN" target="../../..">
          <tran_glyph conn="96,37,1,0,2,-16">
           <action box="-4,-2,9,2"/>
          </tran_glyph>
         </tran>
         <state_glyph node="80,32,16,11">
          <entry box="1,2,5,2"/>
         </state_glyph>
        </state>
        <state name="sim_rdy">
         <initial target="../1">
          <initial_glyph conn="52,52,5,3,4">
           <action box="0,-2,6,2"/>
          </initial_glyph>
         </initial>
         <state name="wait_for_network">
          <documentation>wait for network identification</documentation>
          <entry>/* send AT+COPS? */</entry>
          <tran trig="OPERATOR_SELECTED" target="../../2">
           <tran_glyph conn="81,53,1,0,13,4">
            <action box="0,-2,17,2"/>
           </tran_glyph>
          </tran>
          <state_glyph node="56,50,25,6">
           <entry box="1,2,5,2"/>
          </state_glyph>
         </state>
         <state name="network_rdy">
          <tran trig="READ_SMS" target="../3">
           <tran_glyph conn="52,66,3,3,8">
            <action box="0,-2,10,2"/>
           </tran_glyph>
          </tran>
          <tran trig="SEND_SMS" target="../4">
           <tran_glyph conn="52,76,3,3,8">
            <action box="0,-2,9,2"/>
           </tran_glyph>
          </tran>
          <tran trig="GPRS_CONNECT" target="../5">
           <tran_glyph conn="140,66,1,1,-13">
            <action box="-12,-2,12,2"/>
           </tran_glyph>
          </tran>
          <state name="read_sms">
           <documentation>strictly speaking this works for sms' stored on sim at SIM-ready phase too, but we cannot receive new ones without the network...</documentation>
           <entry>/* initialize the read, set the serialport to raw mode, parse message, emit read-complete signal when done */</entry>
           <exit>/* restore serialport to normal mode */</exit>
           <tran trig="READ_DONE" target="../..">
            <action>/* TODO: what if we were in gprs_ready state ?? */</action>
            <tran_glyph conn="78,66,1,0,4,-9">
             <action box="-6,-2,9,2"/>
            </tran_glyph>
           </tran>
           <state_glyph node="60,62,18,9">
            <entry box="1,2,5,2"/>
            <exit box="1,4,5,2"/>
           </state_glyph>
          </state>
          <state name="send_sms">
           <entry>/* initialize the read, set the serialport to raw mode, send message, emit send-complete signal when done */</entry>
           <exit>/* restore serialport to normal mode */</exit>
           <tran trig="SEND_DONE" target="../..">
            <action>/* TODO: what if we were in gprs_ready state ?? */</action>
            <tran_glyph conn="78,78,1,0,8,-21">
             <action box="-4,-2,10,2"/>
            </tran_glyph>
           </tran>
           <state_glyph node="60,73,18,9">
            <entry box="1,2,5,2"/>
            <exit box="1,4,5,2"/>
           </state_glyph>
          </state>
          <state name="configure_gprs">
           <documentation>/* configure APN, enable connection */</documentation>
           <entry>/* query gprs state, send configuration commands */</entry>
           <tran trig="GPRS_CONNECTED" target="../../6">
            <tran_glyph conn="124,72,2,0,12">
             <action box="-13,-2,16,2"/>
            </tran_glyph>
           </tran>
           <state_glyph node="103,62,24,10">
            <entry box="1,2,5,2"/>
           </state_glyph>
          </state>
          <state name="gprs_ready">
           <tran trig="GPRS_DISCONNECT" target="../..">
            <tran_glyph conn="100,84,0,0,-27">
             <action box="0,-2,16,2"/>
            </tran_glyph>
           </tran>
           <state name="HTTP_connection">
            <documentation>TODO: document this and model the substates and whatnot</documentation>
            <state_glyph node="58,90,18,12"/>
           </state>
           <state name="socket_connection">
            <documentation>TODO: document this and model the substates and whatnot</documentation>
            <state_glyph node="82,91,22,12"/>
           </state>
           <state_glyph node="54,84,85,48"/>
          </state>
          <state_glyph node="52,57,88,76"/>
         </state>
         <state_glyph node="50,46,91,88"/>
        </state>
        <state_glyph node="48,26,94,109">
         <entry box="1,2,5,2"/>
        </state_glyph>
       </state>
       <state_glyph node="37,21,106,115">
        <entry box="1,2,5,2"/>
       </state_glyph>
      </state>
      <state_glyph node="34,9,110,128">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state_glyph node="22,5,123,134">
      <entry box="1,2,5,2"/>
      <exit box="1,4,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="153,187"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="project.h">
   <text>#include &quot;qp_port.h&quot;

$define(AOs::MyAO)

/* define some other functions */</text>
  </file>
  <file name="myao.c"/>
 </directory>
</model>

<?xml version="1.0" encoding="UTF-8"?>
<model version="2.3.2">
 <documentation>Simple model template for QP/C</documentation>
 <framework name="qpc"/>
 <package name="Events" stereotype="0x01">
  <class name="MyEvt" superclass="qpc::QEvt">
   <attribute name="attr1" type="" visibility="0x00" properties="0x00"/>
  </class>
 </package>
 <package name="AOs" stereotype="0x02">
  <class name="SerialDrv" superclass="qpc::QActive">
   <documentation>GSM Serial port driver
</documentation>
   <attribute name="listen_timeout" type="QTimeEvt" visibility="0x02" properties="0x00"/>
   <statechart>
    <initial target="../1">
     <action>/* subscribe to the turn_on and turn_off signals */</action>
     <initial_glyph conn="4,2,5,0,8,3">
      <action box="0,-2,6,2"/>
     </initial_glyph>
    </initial>
    <state name="off">
     <entry>/* disable serial peripheral to conserve power */</entry>
     <tran trig="TURN_ON" target="../../2">
      <tran_glyph conn="22,9,1,3,11,1,2">
       <action box="0,-2,9,2"/>
      </tran_glyph>
     </tran>
     <state_glyph node="4,5,18,12">
      <entry box="1,2,13,8"/>
     </state_glyph>
    </state>
    <state name="on">
     <entry>/* Enable serial peripheral, keep module serialport enabled via DTR */</entry>
     <exit>/* put module to sleep via DTR */</exit>
     <initial target="../5">
      <action>/* subscribe to the signals used */</action>
      <initial_glyph conn="46,13,4,0,3">
       <action box="2,0,6,2"/>
      </initial_glyph>
     </initial>
     <tran trig="TURN_OFF" target="../../1">
      <tran_glyph conn="35,15,3,1,-11,-1,-2">
       <action box="-10,-2,10,3"/>
      </tran_glyph>
     </tran>
     <state name="idle">
      <entry>/* put the module to sleep via DTR */</entry>
      <exit>/* wake the module via DTR */</exit>
      <tran trig="RING" target="../../3">
       <action>/* we suppose the module wakes it's serialport in this case automagically */</action>
       <tran_glyph conn="71,26,2,0,6">
        <action box="-6,1,6,2"/>
       </tran_glyph>
      </tran>
      <tran trig="TX_BUFFER_RDY" target="../../6">
       <tran_glyph conn="67,24,3,0,-11,5">
        <action box="-17,2,14,2"/>
       </tran_glyph>
      </tran>
      <tran trig="ENTER_RAW_MODE" target="../../4">
       <tran_glyph conn="86,18,0,1,-1,23,46,-30">
        <action box="-1,-3,16,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="67,18,24,8">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="Listening">
      <documentation>/* TODO: how the poll for the serialport, I guess incoming data would have to be modelled as signals too */</documentation>
      <entry>/* arm the listen timer, keep the module seriaport enabled via DTR */</entry>
      <exit>/* disarm the timer */</exit>
      <tran trig="TIMEOUT" target="../../2">
       <action>/* Signal the caller about error somehow */</action>
       <tran_glyph conn="92,40,1,1,4,-17,-5">
        <action box="4,-2,9,2"/>
       </tran_glyph>
      </tran>
      <tran trig="MESSAGE_RECEIVED" target="../../2">
       <action>/* signal the message contents at least to the module state machine */</action>
       <tran_glyph conn="87,32,0,2,-6">
        <action box="-8,-3,17,2"/>
       </tran_glyph>
      </tran>
      <tran trig="DATA_RECEIVED">
       <action>/* parse the data, signal MESSAGE_RECEIVED if we have a full line of data */</action>
       <tran_glyph conn="66,42,3,-1,10">
        <action box="0,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="66,32,26,16">
       <entry box="1,2,5,2"/>
       <exit box="1,4,5,2"/>
      </state_glyph>
     </state>
     <state name="raw_mode">
      <documentation>raw mode for sms/ip/whatnot, normal message parsing is disabled</documentation>
      <tran trig="EXIT_RAW_MODE" target="../../2">
       <tran_glyph conn="79,67,1,1,27,-46,-15">
        <action box="0,-2,14,2"/>
       </tran_glyph>
      </tran>
      <state_glyph node="40,58,39,14"/>
     </state>
     <state name="initializing">
      <entry>/* Initialize the serialport and module sleep modes,signal INIT_DONE when ready */</entry>
      <tran trig="INIT_DONE" target="../../2">
       <tran_glyph conn="55,20,1,3,10,2,2">
        <action box="0,-2,9,3"/>
       </tran_glyph>
      </tran>
      <state_glyph node="38,16,17,8">
       <entry box="1,2,15,3"/>
      </state_glyph>
     </state>
     <state name="tx_super">
      <initial target="../1">
       <action>/* TODO: make a choice that checks whether module was asleep or not */</action>
       <initial_glyph conn="56,33,4,1,3,-2">
        <action box="0,-2,6,2"/>
       </initial_glyph>
      </initial>
      <state name="module_wakeup">
       <entry>/* wakeup the module via DTR (though exiting idle should have done this already), arm timer for the required wakeup time */</entry>
       <tran trig="TIMEOUT" target="../../2">
        <tran_glyph conn="50,39,2,0,0,-1,2">
         <action box="-3,-2,8,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="37,32,17,7">
        <entry box="1,2,5,2"/>
       </state_glyph>
      </state>
      <state name="trasmitting">
       <entry>/* arm the tx_timeout timer, transmit the buffer, signal buffer_done when ready */</entry>
       <exit>/* disarm tx_timeout */</exit>
       <tran trig="TX_BUFFER_DONE" target="../../../3">
        <tran_glyph conn="53,45,1,3,13">
         <action box="-2,-2,17,2"/>
        </tran_glyph>
       </tran>
       <tran trig="TIMEOUT" target="../../../2">
        <action>/* signal TX failure */</action>
        <tran_glyph conn="45,48,2,0,4,59,-38,-25,4">
         <action box="1,1,10,2"/>
        </tran_glyph>
       </tran>
       <state_glyph node="37,41,16,7">
        <entry box="1,2,5,2"/>
        <exit box="1,4,5,2"/>
       </state_glyph>
      </state>
      <state_glyph node="36,29,24,24"/>
     </state>
     <state_glyph node="35,6,80,70">
      <entry box="1,2,7,2"/>
      <exit box="1,4,5,2"/>
     </state_glyph>
    </state>
    <state_diagram size="116,108"/>
   </statechart>
  </class>
 </package>
 <directory name=".">
  <file name="project.h">
   <text>#include &quot;qp_port.h&quot;

$define(AOs::MyAO)

/* define some other functions */</text>
  </file>
  <file name="myao.c"/>
 </directory>
</model>
